package com.example.fido.constants.clickhouse;

/*
https://clickhouse.com/docs/ru/sql-reference/functions/array-functions
*/
public final class ClickHouseArrayFunctions {
    /*
    range(end), range([start, ] end [, step])

    Возвращает массив чисел от start до end - 1 с шагом step.
    Синтаксис
        range([start, ] end [, step])

    Аргументы

    start — начало диапазона. Обязательно, когда указан step. По умолчанию равно 0. Тип: UInt
    end — конец диапазона. Обязательный аргумент. Должен быть больше, чем start. Тип: UInt
    step — шаг обхода. Необязательный аргумент. По умолчанию равен 1. Тип: UInt

    Особенности реализации

    Не поддерживаются отрицательные значения аргументов: start, end, step имеют тип UInt.

    Если в результате запроса создаются массивы суммарной длиной больше, чем количество элементов, указанное настройкой function_range_max_elements_in_block, то генерируется исключение.

    Возвращает Null если любой аргумент Nullable(Nothing) типа. Генерируется исключение если любой аргумент Null (Nullable(T) тип).

    Примеры:
    Запрос:
        SELECT range(5), range(1, 5), range(1, 5, 2);

    Ответ:

    ┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┐
    │ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │
    └─────────────┴─────────────┴────────────────┘
     */
    public static final String RANGE = "range";

    /*
    has(arr, elem)

    Проверяет наличие элемента elem в массиве arr. Возвращает 0, если элемента в массиве нет, или 1, если есть.

    NULL обрабатывается как значение.

    SELECT has([1, 2, NULL], NULL)
    ┌─has([1, 2, NULL], NULL)─┐
    │                       1 │
    └─────────────────────────┘
     */
    public static final String HAS = "has";

    /*
    Проверяет, является ли один массив подмножеством другого.

    hasAll(set, subset)

    Аргументы
        set – массив любого типа с набором элементов.
        subset – массив любого типа со значениями, которые проверяются на вхождение в set.

    Возвращаемые значения
        1, если set содержит все элементы из subset.
        0, в противном случае.

    Особенности
        Пустой массив является подмножеством любого массива.
        NULL обрабатывается как значение.
        Порядок значений в обоих массивах не имеет значения.

    Примеры
    SELECT hasAll([], []) возвращает 1.
    SELECT hasAll([1, Null], [Null]) возвращает 1.
    SELECT hasAll([1.0, 2, 3, 4], [1, 3]) возвращает 1.
    SELECT hasAll(['a', 'b'], ['a']) возвращает 1.
    SELECT hasAll([1], ['a']) возвращает 0.
    SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]]) возвращает 0.
     */
    public static final String HAS_ALL = "hasAll";

    /*
    Проверяет, имеют ли два массива хотя бы один общий элемент.

    hasAny(array1, array2)

    Аргументы
        array1 – массив любого типа с набором элементов.
        array2 – массив любого типа с набором элементов.

    Возвращаемые значения
        1, если array1 и array2 имеют хотя бы один одинаковый элемент.
        0, в противном случае.

    Особенности
        NULL обрабатывается как значение.
        Порядок значений в обоих массивах не имеет значения.

    Примеры
    SELECT hasAny([1], []) возвращает 0.
    SELECT hasAny([Null], [Null, 1]) возвращает 1.
    SELECT hasAny([-128, 1., 512], [1]) возвращает 1.
    SELECT hasAny([[1, 2], [3, 4]], ['a', 'c']) возвращает 0.
    SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]]) возвращает 1.
     */
    public static final String HAS_ANY = "hasAny";

    /*
    Возвращает индекс первого элемента x (начиная с 1), если он есть в массиве, или 0, если его нет.

    Пример:
    SELECT indexOf([1, 3, NULL, NULL], NULL)

    ┌─indexOf([1, 3, NULL, NULL], NULL)─┐
    │                                 3 │
    └───────────────────────────────────┘

    Элементы, равные NULL, обрабатываются как обычные значения.
     */
    public static final String INDEX_OF = "indexOf";

    /*
    https://clickhouse.com/docs/ru/sql-reference/functions/array-join#functions_arrayjoin
     */
    public static final String ARRAY_JOIN = "arrayJoin";

    /*
    Объединяет несколько массивов в один. Результирующий массив содержит соответственные элементы исходных массивов, сгруппированные в кортежи в указанном порядке аргументов.

    Синтаксис
    arrayZip(arr1, arr2, ..., arrN)

    Аргументы
        arrN — массив.

    Функция принимает любое количество массивов, которые могут быть различных типов. Все массивы должны иметь одинаковую длину.

    Возвращаемое значение
        Массив с элементами исходных массивов, сгруппированными в кортежи.
        Типы данных в кортежах соответствуют типам данных входных массивов и следуют в том же порядке, в котором переданы массивы.

    Тип: Массив.

    Пример
    Запрос:
    SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);

    Результат:
    ┌─arrayZip(['a', 'b', 'c'], [5, 2, 1])─┐
    │ [('a',5),('b',2),('c',1)]            │
    └──────────────────────────────────────┘
     */
    public static final String ARRAY_ZIP = "arrayZip";

    /*
    Возвращает массив, полученный на основе результатов применения функции func к каждому элементу массива arr.

    Примеры:
    SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;

    ┌─res─────┐
    │ [3,4,5] │
    └─────────┘

    Следующий пример показывает, как создать кортежи из элементов разных массивов:

    SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res;

    ┌─res─────────────────┐
    │ [(1,4),(2,5),(3,6)] │
    └─────────────────────┘

    Функция arrayMap является функцией высшего порядка — в качестве первого аргумента ей нужно передать лямбда-функцию, и этот аргумент не может быть опущен.
     */
    public static final String ARRAY_MAP = "arrayMap";

    /*
    Возвращает 1, если для всех элементов массива arr, функция func возвращает не 0. Иначе возвращает 0.

    Функция arrayAll является функцией высшего порядка - в качестве первого аргумента ей можно передать лямбда-функцию.
     */
    public static final String ARRAY_ALL = "arrayAll";

    /*
    Возвращает значение минимального элемента в исходном массиве.

    Если передана функция func, возвращается минимум из элементов массива, преобразованных этой функцией.

    Функция arrayMin является функцией высшего порядка — в качестве первого аргумента ей можно передать лямбда-функцию.

    Синтаксис
        arrayMin([func,] arr)

    Аргументы
        func — функция. Expression.
        arr — массив. Array.

    Возвращаемое значение
        Минимальное значение функции (или минимальный элемент массива).

    Тип: если передана func, соответствует типу ее возвращаемого значения, иначе соответствует типу элементов массива.

    Примеры
    Запрос:
    SELECT arrayMin([1, 2, 4]) AS res;

    Результат:
    ┌─res─┐
    │   1 │
    └─────┘

    Запрос:
        SELECT arrayMin(x -> (-x), [1, 2, 4]) AS res;

    Результат:
    ┌─res─┐
    │  -4 │
    └─────┘
     */
    public static final String ARRAY_MIN = "arrayMin";

    /*
    Возвращает массив, содержащий только те элементы массива arr1, для которых функция func возвращает не 0.

    Примеры:

    SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res

    ┌─res───────────┐
    │ ['abc World'] │
    └───────────────┘

    SELECT
        arrayFilter(
            (i, x) -> x LIKE '%World%',
            arrayEnumerate(arr),
            ['Hello', 'abc World'] AS arr)
        AS res

    ┌─res─┐
    │ [2] │
    └─────┘

    Функция arrayFilter является функцией высшего порядка — в качестве первого аргумента ей нужно передать лямбда-функцию, и этот аргумент не может быть опущен.
     */
    public static final String ARRAY_FILTER = "arrayFilter";

    /*
    Перебирает arr1 от первого элемента к последнему и заменяет arr1[i] на arr1[i - 1], если func вернула 0. Первый элемент arr1 остаётся неизменным.

    Примеры:

    SELECT arrayFill(x -> not isNull(x), [1, null, 3, 11, 12, null, null, 5, 6, 14, null, null]) AS res

    ┌─res──────────────────────────────┐
    │ [1,1,3,11,12,12,12,5,6,14,14,14] │
    └──────────────────────────────────┘

    Функция arrayFill является функцией высшего порядка — в качестве первого аргумента ей нужно передать лямбда-функцию, и этот аргумент не может быть опущен.
     */
    public static final String ARRAY_FILL = "arrayFill";

    /*
    Разделяет массив arr1 на несколько. Если func возвращает не 0, то массив разделяется, а элемент помещается в левую часть. Массив не разбивается по первому элементу.

    Примеры:

    SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
    ┌─res─────────────┐
    │ [[1,2,3],[4,5]] │
    └─────────────────┘

    Функция arraySplit является функцией высшего порядка — в качестве первого аргумента ей нужно передать лямбда-функцию, и этот аргумент не может быть опущен.
     */
    public static final String ARRAY_SPLIT = "arraySplit";

    /*
    Вычисляет разность между соседними элементами массива. Возвращает массив, где первым элементом будет 0, вторым – разность a[1] - a[0] и т. д. Тип элементов результирующего массива определяется правилами вывода типов при вычитании (напр. UInt8 - UInt8 = Int16).

    Синтаксис

    arrayDifference(array)

    Аргументы
        array – массив.

    Возвращаемое значение
    Возвращает массив разностей между соседними элементами.

    Пример
    Запрос:
    SELECT arrayDifference([1, 2, 3, 4]);

    Результат:

    ┌─arrayDifference([1, 2, 3, 4])─┐
    │ [0,1,1,1]                     │
    └───────────────────────────────┘

    Пример переполнения из-за результирующего типа Int64:

    Запрос:

    SELECT arrayDifference([0, 10000000000000000000]);

    Результат:

    ┌─arrayDifference([0, 10000000000000000000])─┐
    │ [0,-8446744073709551616]                   │
    └────────────────────────────────────────────┘
     */
    public static final String ARRAY_DIFFERENCE = "arrayDifference";

    /*
    Принимает массив, возвращает массив, содержащий уникальные элементы.

    Синтаксис

    arrayDistinct(array)

    Аргументы
        array – массив.

    Возвращаемое значение
    Возвращает массив, содержащий только уникальные элементы исходного массива.

    Пример
    Запрос:
    SELECT arrayDistinct([1, 2, 2, 3, 1]);

    Ответ:
        ┌─arrayDistinct([1, 2, 2, 3, 1])─┐
        │ [1,2,3]                        │
        └────────────────────────────────┘
     */
    public static final String ARRAY_DISTINCT = "arrayDistinct";

    /*
    Принимает несколько массивов, возвращает массив с элементами, присутствующими во всех исходных массивах.

    Пример:

    SELECT
        arrayIntersect([1, 2], [1, 3], [2, 3]) AS no_intersect,
        arrayIntersect([1, 2], [1, 3], [1, 4]) AS intersect

    ┌─no_intersect─┬─intersect─┐
    │ []           │ [1]       │
    └──────────────┴───────────┘
     */
    public static final String ARRAY_INTERSECT = "arrayIntersect";

    /*
    Применяет агрегатную функцию к элементам массива и возвращает ее результат. Имя агрегирующей функции передается как строка в одинарных кавычках 'max', 'sum'. При использовании параметрических агрегатных функций, параметр указывается после имени функции в круглых скобках 'uniqUpTo(6)'.

    Синтаксис

    arrayReduce(agg_func, arr1, arr2, ..., arrN)

    Аргументы
        agg_func — Имя агрегатной функции, которая должна быть константой string.
        arr — Любое количество столбцов типа array в качестве параметров агрегатной функции.

    Возвращаемое значение
    Пример
    Запрос:
    SELECT arrayReduce('max', [1, 2, 3]);

    Результат:
    ┌─arrayReduce('max', [1, 2, 3])─┐
    │                             3 │
    └───────────────────────────────┘

    Если агрегатная функция имеет несколько аргументов, то эту функцию можно применять к нескольким массивам одинакового размера.

    Пример
    Запрос:
    SELECT arrayReduce('maxIf', [3, 5], [1, 0]);

    Результат:
    ┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
    │                                    3 │
    └──────────────────────────────────────┘

    Пример с параметрической агрегатной функцией:
    Запрос:
    SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

    Результат:
    ┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
    │                                                           4 │
    └─────────────────────────────────────────────────────────────┘
     */
    public static final String ARRAY_REDUCE = "arrayReduce";

    /*
    arrayCount([func,] arr1, …)

    Возвращает количество элементов массива arr, для которых функция func возвращает не 0.
    Если func не указана - возвращает количество ненулевых элементов массива.

    Функция arrayCount является функцией высшего порядка — в качестве первого аргумента ей можно передать лямбда-функцию.
     */
    public static final String ARRAY_COUNT = "arrayCount";

    /*
    countEqual(arr, x)

    Возвращает количество элементов массива, равных x. Эквивалентно arrayCount(elem -> elem = x, arr).

    NULL обрабатывается как значение.

    Пример:
        SELECT countEqual([1, 2, NULL, NULL], NULL)

    ┌─countEqual([1, 2, NULL, NULL], NULL)─┐
    │                                    2 │
    └──────────────────────────────────────┘
     */
    public static final String COUNT_EQUAL = "countEqual";

    /*
    Возвращает массив [1, 2, 3, …, length(arr)]

    Эта функция обычно используется совместно с ARRAY JOIN. Она позволяет, после применения ARRAY JOIN, посчитать что-либо только один раз для каждого массива. Пример:

    SELECT
        count() AS Reaches,
        countIf(num = 1) AS Hits
    FROM test.hits
    ARRAY JOIN
        GoalsReached,
        arrayEnumerate(GoalsReached) AS num
    WHERE CounterID = 160656
    LIMIT 10

    ┌─Reaches─┬──Hits─┐
    │   95606 │ 31406 │
    └─────────┴───────┘

    В этом примере, Reaches - число достижений целей (строк, получившихся после применения ARRAY JOIN),
    а Hits - число хитов (строк, которые были до ARRAY JOIN). В данном случае, тот же результат можно получить проще:

    SELECT
        sum(length(GoalsReached)) AS Reaches,
        count() AS Hits
    FROM test.hits
    WHERE (CounterID = 160656) AND notEmpty(GoalsReached)

    ┌─Reaches─┬──Hits─┐
    │   95606 │ 31406 │
    └─────────┴───────┘

    Также эта функция может быть использована в функциях высшего порядка.
    Например, с её помощью можно достать индексы массива для элементов, удовлетворяющих некоторому условию.
    */
    public static final String ARRAY_ENUMERATE = "arrayEnumerate";

    /*
    Возвращает срез массива.

    arraySlice(array, offset[, length])

    Аргументы
        array – массив данных.
        offset – отступ от края массива. Положительное значение - отступ слева, отрицательное значение - отступ справа. Отсчёт элементов массива начинается с 1.
        length – длина необходимого среза. Если указать отрицательное значение, то функция вернёт открытый срез [offset, array_length - length].
        Если не указать значение, то функция вернёт срез [offset, the_end_of_array].

    Пример
        SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;

        ┌─res────────┐
        │ [2,NULL,4] │
        └────────────┘

    Элементы массива равные NULL обрабатываются как обычные значения.
     */
    public static final String ARRAY_SLICE = "arraySlice";

    /*
    Возвращает массив arr, отсортированный в восходящем порядке. Если задана функция func, то порядок сортировки определяется результатом применения этой функции на элементы массива arr. Если func принимает несколько аргументов, то в функцию arraySort нужно передавать несколько массивов, которые будут соответствовать аргументам функции func. Подробные примеры рассмотрены в конце описания arraySort.

    Пример сортировки целочисленных значений:
    SELECT arraySort([1, 3, 3, 0])

    ┌─arraySort([1, 3, 3, 0])─┐
    │ [0,1,3,3]               │
    └─────────────────────────┘

    Пример сортировки строковых значений:
    SELECT arraySort(['hello', 'world', '!'])

    ┌─arraySort(['hello', 'world', '!'])─┐
    │ ['!','hello','world']              │
    └────────────────────────────────────┘

    Значения NULL, NaN и Inf сортируются по следующему принципу:

    SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);

    ┌─arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf])─┐
    │ [-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]                     │
    └───────────────────────────────────────────────────────────┘

        Значения -Inf идут в начале массива.
        Значения NULL идут в конце массива.
        Значения NaN идут перед NULL.
        Значения Inf идут перед NaN.

    Функция arraySort является функцией высшего порядка — в качестве первого аргумента ей можно передать лямбда-функцию.
    В этом случае порядок сортировки определяется результатом применения лямбда-функции на элементы массива.

    Рассмотрим пример:

    SELECT arraySort((x) -> -x, [1, 2, 3]) as res;

    ┌─res─────┐
    │ [3,2,1] │
    └─────────┘

    Для каждого элемента исходного массива лямбда-функция возвращает ключ сортировки, то есть [1 –> -1, 2 –> -2, 3 –> -3].
    Так как arraySort сортирует элементы в порядке возрастания ключей, результат будет [3, 2, 1].
    Как можно заметить, функция x –> -x устанавливает обратный порядок сортировки.

    Лямбда-функция может принимать несколько аргументов.
    В этом случае, в функцию arraySort нужно передавать несколько массивов,
    которые будут соответствовать аргументам лямбда-функции (массивы должны быть одинаковой длины). Следует иметь в виду,
    что результат будет содержать элементы только из первого массива;
    элементы из всех последующих массивов будут задавать ключи сортировки. Например:

    SELECT arraySort((x, y) -> y, ['hello', 'world'], [2, 1]) as res;

    ┌─res────────────────┐
    │ ['world', 'hello'] │
    └────────────────────┘

    Элементы, указанные во втором массиве ([2,1]), определяют ключ сортировки для элементов из исходного массива ([‘hello’, ‘world’]), то есть [‘hello’ –> 2, ‘world’ –> 1].
    Так как лямбда-функция не использует x, элементы исходного массива не влияют на порядок сортировки.
    Таким образом, ‘hello’ будет вторым элементом в отсортированном массиве, а ‘world’ — первым.

    Ниже приведены другие примеры.

    SELECT arraySort((x, y) -> y, [0, 1, 2], ['c', 'b', 'a']) as res;

    ┌─res─────┐
    │ [2,1,0] │
    └─────────┘

    SELECT arraySort((x, y) -> -y, [0, 1, 2], [1, 2, 3]) as res;

    ┌─res─────┐
    │ [2,1,0] │
     */
    public static final String ARRAY_SORT = "arraySort";

    /*
    Объединяет массивы, переданные в качестве аргументов.

    arrayConcat(arrays)
    Аргументы
        arrays – произвольное количество элементов типа ArrayПример

    SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
    ┌─res───────────┐
    │ [1,2,3,4,5,6] │
    └───────────────┘
     */
    public static final String ARRAY_CONCAT = "arrayConcat";

    /*
    Преобразует массив массивов в плоский массив.

    Функция:
        Оперирует с массивами любой вложенности.
        Не изменяет массив, если он уже плоский.

    Результирующий массив содержит все элементы исходных массивов.

    Синтаксис

    flatten(array_of_arrays)

    Синоним: flatten.

    Аргументы
        array_of_arrays — массив массивов. Например, [[1,2,3], [4,5]].

    Примеры
    SELECT flatten([[[1]], [[2], [3]]]);

    ┌─flatten(array(array([1]), array([2], [3])))─┐
    │ [1,2,3]                                     │
    └─────────────────────────────────────────────┘
     */
    public static final String ARRAY_FLATTEN = "arrayFlatten";

    /*
    Удаляет последовательно повторяющиеся элементы из массива. Порядок результирующих значений определяется порядком в исходном массиве.

    Синтаксис
        arrayCompact(arr)

    Аргументы
    arr — массив для обхода.

    Возвращаемое значение
    Массив без последовательных дубликатов.

    Тип: Array

    Пример
        Запрос:
        SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);

    Результат:
    ┌─arrayCompact([1, 1, nan, nan, 2, 3, 3, 3])─┐
    │ [1,nan,nan,2,3]                            │
    └────────────────────────────────────────────┘
     */
    public static final String ARRAY_COMPACT = "arrayCompact";

    /*
    arrayElement(arr, n), operator arr[n]

    Достаёт элемент с индексом n из массива arr. n должен быть любым целочисленным типом. Индексы в массиве начинаются с единицы.
    Поддерживаются отрицательные индексы. В этом случае, будет выбран соответствующий по номеру элемент с конца.
    Например, arr[-1] - последний элемент массива.

    Если индекс выходит за границы массива, то возвращается некоторое значение по умолчанию (0 для чисел, пустая строка для строк и т. п.),
    кроме случая с неконстантным массивом и константным индексом 0 (в этом случае будет ошибка Array indices are 1-based).
     */
    public static final String ARRAY_ELEMENT = "arrayElement";
    public static final String ARRAY_POP_BACK = "arrayPopBack";
    public static final String ARRAY_POP_FRONT = "arrayPopFront";
    public static final String ARRAY_PUSH_BACK = "arrayPushBack";
    public static final String ARRAY_PUSH_FRONT = "arrayPushFront";

    public static final String ARRAY_REVERSE = "arrayReverse";
    public static final String ARRAY_STRING_CONCAT = "arrayStringConcat";

    /*
    Проверяет, является ли входной массив пустым.
    Синтаксис:
        empty([x])

    Массив считается пустым, если он не содержит ни одного элемента.
    Возвращает 1 для пустого массива или 0 — для непустого массива.
    */
    public static final String EMPTY = "empty";
    /*
    Возвращает количество элементов в массиве. Тип результата - UInt64. Функция также работает для строк.
     */
    public static final String LENGTH = "length";
    /*
    notEmpty
    Проверяет, является ли входной массив непустым.
    Синтаксис
        notEmpty([x])

    Массив считается непустым, если он содержит хотя бы один элемент.
     */
    public static final String NOT_EMPTY = "notEmpty";

    /*
    Возвращает 1, если существует хотя бы один элемент массива arr, для которого функция func возвращает не 0. Иначе возвращает 0.

    Функция arrayExists является функцией высшего порядка - в качестве первого аргумента ей можно передать лямбда-функцию.
     */
    public static final String ARRAY_EXISTS = "arrayExists";
}
