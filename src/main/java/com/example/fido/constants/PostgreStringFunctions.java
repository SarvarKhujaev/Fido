package com.example.fido.constants;

public final class PostgreStringFunctions {
    /*
    https://postgrespro.ru/docs/postgresql/9.6/functions-matching

    Выражение LIKE возвращает true, если строка соответствует заданному шаблону.
    (Как можно было ожидать, выражение NOT LIKE возвращает false, когда LIKE возвращает true, и наоборот.
    Этому выражению равносильно выражение NOT (строка LIKE шаблон).)

    Если шаблон не содержит знаков процента и подчёркиваний,
    тогда шаблон представляет в точности строку и LIKE работает как оператор сравнения.

    Подчёркивание (_) в шаблоне подменяет (вместо него подходит) любой символ;
    а знак процента (%) подменяет любую (в том числе и пустую) последовательность символов.

    При проверке по шаблону LIKE всегда рассматривается вся строка.
    Поэтому, если нужно найти последовательность символов где-то в середине строки,
    шаблон должен начинаться и заканчиваться знаками процента.

    Чтобы найти в строке буквальное вхождение знака процента или подчёркивания,
    перед соответствующим символом в шаблоне нужно добавить спецсимвол.
    По умолчанию в качестве спецсимвола выбрана обратная косая черта,
    но с помощью предложения ESCAPE можно выбрать и другой.
    Чтобы включить спецсимвол в шаблон поиска, продублируйте его.

    Также можно отказаться от спецсимвола, написав ESCAPE ''.
    При этом механизм спецпоследовательностей фактически отключается и использовать знаки процента и подчёркивания буквально в шаблоне нельзя.

    Вместо LIKE можно использовать ключевое слово ILIKE, чтобы поиск был регистр-независимым с учётом текущей языковой среды.
    Этот оператор не описан в стандарте SQL; это расширение PostgreSQL.

    Кроме того, в PostgreSQL есть оператор ~~, равнозначный LIKE, и ~~*, соответствующий ILIKE.
    Есть также два оператора !~~ и !~~*, представляющие NOT LIKE и NOT ILIKE, соответственно.
    Все эти операторы относятся к особенностям PostgreSQL.
    Вы можете увидеть их, например, в выводе команды EXPLAIN, так как при разборе запроса проверка LIKE и подобные заменяются ими.

    Фразы LIKE, ILIKE, NOT LIKE и NOT ILIKE в синтаксисе PostgreSQL обычно обрабатываются как операторы; например,
    их можно использовать в конструкциях выражение оператор ANY (подвыражение), хотя предложение ESCAPE здесь добавить нельзя.
    В некоторых особых случаях всё же может потребоваться использовать вместо них нижележащие операторы.
    */
    public final static String LIKE = "LIKE %s";

    /*
    https://postgrespro.ru/docs/postgresql/9.6/functions-matching <- docs

    ~	Проверяет соответствие регулярному выражению с учётом регистра	'thomas' ~ '.*thomas.*'
    ~*	Проверяет соответствие регулярному выражению без учёта регистра	'thomas' ~* '.*Thomas.*'
    !~	Проверяет несоответствие регулярному выражению с учётом регистра	'thomas' !~ '.*Thomas.*'
    !~*	Проверяет несоответствие регулярному выражению без учёта регистра	'thomas' !~* '.*vadim.*'

    'abc' ~ 'abc'    true
    'abc' ~ '^a'     true
    'abc' ~ '(b|d)'  true
    'abc' ~ '^(b|c)' false

    Регулярные выражения POSIX предоставляют более мощные средства поиска по шаблонам, чем операторы LIKE и SIMILAR TO. Во многих командах Unix, таких как egrep, sed и awk используется язык шаблонов, похожий на описанный здесь.

    Регулярное выражение — это последовательность символов, представляющая собой краткое
    определение набора строк (регулярное множество).
    Строка считается соответствующей регулярному выражению, если она является членом регулярного множества,
    описываемого регулярным выражением. Как и для LIKE, символы шаблона непосредственно соответствуют символам строки,
    за исключением специальных символов языка регулярных выражений.
    При этом спецсимволы регулярных выражений отличается от спецсимволов LIKE.
    В отличие от шаблонов LIKE, регулярное выражение может совпадать с любой частью строки,
    если только оно не привязано явно к началу и/или концу строки.
    */
    public final static String POSIX = "POSIX %s";

    /*
    Функция regexp_matches возвращает текстовый массив из всех подходящих подстрок,
    полученных в результате применения регулярного выражения POSIX.
    Она имеет синтаксис regexp_matches(строка, шаблон [, флаги]).
    Эта функция может вовсе не вернуть строк или вернуть одну или несколько строк (см. описание флага g ниже).
    Если шаблон не находится в строке, функция не возвращает строк.
    Если шаблон не содержит подвыражений в скобках, тогда для каждой строки возвращается массив с одним элементом,
    содержащим подстроку, соответствующую всему шаблону.
    Если же шаблон содержит подвыражения в скобках, функция возвращает массив элементов,
    в котором n-й элемент соответствует n-му подвыражению в скобках (не считая скобки «без захвата»; подробнее об этом ниже).
    В необязательном параметре флаги передаётся текстовая строка, содержащая ноль или более однобуквенных флагов,
    меняющих поведение функции. Флаг g указывает, что функция должна находить в строке не только первое,
    а все соответствия шаблону, и возвращать строку для каждого соответствия. Допустимые флаги (кроме g) описаны

    SELECT regexp_matches('foobarbequebaz', '(bar)(beque)');
     regexp_matches
    ----------------
     {bar,beque}
    (1 row)

    SELECT regexp_matches(
     'foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
     regexp_matches
    ----------------
     {bar,beque}
     {bazil,barf}
    (2 rows)

    SELECT regexp_matches('foobarbequebaz', 'barbeque');
     regexp_matches
    ----------------
     {barbeque}
    (1 row)
    */
    public final static String REGEXP_MATCHES = "regexp_replace ( %s, %s, %s )";

    /*
    Функция regexp_replace подставляет другой текст вместо подстрок, соответствующих шаблонам регулярных выражений POSIX.
    Она имеет синтаксис regexp_replace(исходная_строка, шаблон, замена [, флаги]).
    Если исходная_строка не содержит фрагмента, подходящего под шаблон, она возвращается неизменной.
    Если же соответствие находится, возвращается исходная_строка, в которой вместо соответствующего фрагмента подставляется замена.
    Строка замена может содержать \n, где n — число от 1 до 9, указывающее на исходный фрагмент,
    соответствующий n-ому подвыражению в скобках, и может содержать обозначение \&, указывающее,
    что будет вставлен фрагмент, соответствующий всему шаблону.
    Если же в текст замены нужно включить обратную косую черту буквально, следует написать \\.
    В необязательном параметре флаги передаётся текстовая строка, содержащая ноль или более однобуквенных флагов,
    меняющих поведение функции. Флаг i включает поиск без учёта регистра, а флаг g указывает,
    что заменяться должны все подходящие подстроки, а не только первая из них.

    Допустимые флаги (кроме g):
        regexp_replace('foobarbaz', 'b..', 'X')
                                   fooXbaz
        regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                           fooXX
        regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
                                           fooXarYXazY
     */
    public final static String REGEXP_REPLACE = "regexp_replace ( %s, %s, %s )";

    /*
    SELECT format('Hello %s', 'World');
    Результат: Hello World

    SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
    Результат: Testing one, two, three, %

    SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
    Результат: INSERT INTO "Foo bar" VALUES('O''Reilly')

    SELECT format('INSERT INTO %I VALUES(%L)', 'locations', 'C:\Program Files');
    Результат: INSERT INTO locations VALUES('C:\Program Files')
    */
    public final static String FORMAT = "FORMAT %s";

    /*
    https://postgrespro.ru/docs/postgresql/9.6/functions-matching <- docs

    Оператор SIMILAR TO возвращает true или false в зависимости от того, соответствует ли данная строка шаблону или нет.
    Он работает подобно оператору LIKE, только его шаблоны соответствуют определению регулярных выражений в стандарте SQL.
    Регулярные выражения SQL представляют собой любопытный гибрид синтаксиса LIKE с синтаксисом обычных регулярных выражений.

    Как и LIKE, условие SIMILAR TO истинно, только если шаблон соответствует всей строке;
    это отличается от условий с регулярными выражениями, в которых шаблон может соответствовать любой части строки.
    Также подобно LIKE, SIMILAR TO воспринимает символы _ и % как знаки подстановки,
    подменяющие любой один символ или любую подстроку, соответственно (в регулярных выражениях POSIX им аналогичны символы . и .*).

    Помимо средств описания шаблонов, позаимствованных от LIKE, SIMILAR TO поддерживает следующие метасимволы,
    унаследованные от регулярных выражений POSIX:
            | означает выбор (одного из двух вариантов).

            * означает повторение предыдущего элемента 0 и более раз.

            + означает повторение предыдущего элемента 1 и более раз.

            ? означает вхождение предыдущего элемента 0 или 1 раз.

            {m} означает повторяет предыдущего элемента ровно m раз.

            {m,} означает повторение предыдущего элемента m или более раз.

            {m,n} означает повторение предыдущего элемента не менее чем m и не более чем n раз.

            Скобки () объединяют несколько элементов в одну логическую группу.

            Квадратные скобки [...] обозначают класс символов так же, как и в регулярных выражениях POSIX.

    'abc' SIMILAR TO 'a'        false
    'abc' SIMILAR TO 'abc'      true
    'abc' SIMILAR TO '(b|c)%'   false
    'abc' SIMILAR TO '%(b|d)%'  true
    */
    public final static String SIMILAR_TO = "SIMILAR TO %s";
}
